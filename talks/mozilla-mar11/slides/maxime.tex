% Maxime's TOC
%
% IR
% - HIR
% - IR types
% - LIR
% - IIR
%   - Annotations
%
% IR support: static definitions
% IR support: auto-generated code
% - layouts and their methods (alloc/init, accessors)
% - GC visit code
% - FFI wrappers
%
% Compilation phases
% - Present before IR?
% - Picture
%   - Parsing
%   - AST simplification/annotation
%   - AST->IR conversion
%   - IR lowering/optimization
%   - Register allocation
%   - Machine code generation
%
% Optimistic optimizations
% - Optimization issues
% - Getting rid of guards
% - Picture(s)
%   - Specialization
%   - Execution model
% - Less about type profiling?
% - Less about related work?

%
% Slide about compilation phases, with graphic
%
\begin{frame}{Compilation Phases}
\begin{center}
\includegraphics[width=4.5in]{images/phases}
\end{center}
\end{frame}

%
% Example of program JS->AST->HIR->LIR->ASM
%

\begin{frame}{Example: Simple Function}
\lstinputlisting{images/ex_source.js}
\end{frame}

\begin{frame}{Example: Abstract Syntax Tree}
\tiny\verbatiminput{images/ex_ast.txt}
\end{frame}

\begin{frame}{Example: High-level IR}
\tiny\verbatiminput{images/ex_hir.txt}
\end{frame}

\begin{frame}{Example: Low-level IR}
\tiny\verbatiminput{images/ex_lir.txt}
\end{frame}

\begin{frame}{Example: Machine Code}
\begin{columns}[t]

\begin{column}{0.33\textwidth}
\tiny\verbatiminput{images/ex_asm1.txt}
\end{column}

\begin{column}{0.33\textwidth}
\tiny\verbatiminput{images/ex_asm2.txt}
\end{column}

\begin{column}{0.33\textwidth}
\tiny\verbatiminput{images/ex_asm3.txt}
\end{column}

\end{columns}
\end{frame}

% -- Slide ---------------------------------------------------------------------
\begin{frame}{High-Level IR}
    \begin{itemize}

        \item Core JS semantics expressed in terms of HIR instructions
        \begin{itemize}
            \item Act on boxed, high-level (dynamic) types
            \begin{itemize}
                \item Strings, numbers, objects, \ldots
            \end{itemize}
            \item May produce exceptions in some cases
        \end{itemize}

        \item Examples
        \begin{itemize}
            \item Arithmetic/comparison operators (+, -, *, /, $<$, \ldots)
            \item Property accesses (getProp, putProp, hasProp, \ldots)
            \item Other misc. JavaScript operators (typeof, instanceof, \ldots)
        \end{itemize}

        \item Currently, HIR implemented directly by primitive functions
        \begin{itemize}
            \item Primitives written in terms of extended JS
            \item Annotated for performance
                \begin{itemize}
                    \item Static linkage, force inlining, no exceptions, etc.
                \end{itemize}
        \end{itemize}

    \end{itemize}
\end{frame}
% ------------------------------------------------------------------------------

% -- Slide ---------------------------------------------------------------------
\begin{frame}{JavaScript Extensions}
    \begin{itemize}
        \item JavaScript has no access to raw memory
        \begin{itemize}
            \item Essential to implement a VM/JIT
        \end{itemize}
        \item Tachyon is written in JS w/ “unsafe” extensions
        \begin{itemize}
            \item Minimizes the need to write C code (FFI)
            \item Maximizes performance
            \begin{itemize}
                \item FFIs are optimization boundaries
            \end{itemize}
        \end{itemize}
        \item JS code translated to low-level typed IR
        \begin{itemize}
            \item JS extensions: insert typed instructions in code as it is translated (Inline IR / IIR)
        \end{itemize}
    \end{itemize}
\end{frame}
% ------------------------------------------------------------------------------

% -- Slide ---------------------------------------------------------------------
\begin{frame}{Low-Level IR}
    \begin{itemize}
        \item Some similarities with LLVM
        \item SSA-based
        \item Type-annotated
        \begin{itemize}
            \item Integers, floats, booleans, raw pointers
            \item Boxed values, references
        \end{itemize}
        \item Low-level
        \begin{itemize}
            \item Mirrors instructions commonly found on most CPUs
            \begin{itemize}
                \item add/sub/mul/div, and/or/shift, jump/if/call, load/store, etc.
            \end{itemize}
            \item Still tries to be “machine agnostic”
            \begin{itemize}
                \item No specific endianness, no registers
            \end{itemize}
            \item Allows expressing more optimizations (specialization)
        \end{itemize}
    \end{itemize}
\end{frame}
% ------------------------------------------------------------------------------

\begin{frame}{Primitive Functions}
    \begin{itemize}
        \item All Tachyon functions can use extended JS, meaning:
        \begin{itemize}
            \item Special function annotations
            \item Typed local variables
            \item Inline IR (IIR) instructions
        \end{itemize}
        \item Core of the run-time makes more use of this
        \begin{itemize}
            \item Rest of Tachyon mostly uses "standard" JS
        \end{itemize}
        \item Annotations can make functions:
        \begin{itemize}
            \item Have static linkage (no dynamic lookup)
            \item Always be inlined
            \item Be prevented from accessing the global object
            \item Use typed argument values
            \item Use a typed return value
        \end{itemize}
    \end{itemize}
\end{frame}

% -- Slide ---------------------------------------------------------------------
\begin{frame}{}
\lstinputlisting{images/lt.js}
\end{frame}
% ------------------------------------------------------------------------------

% -- Slide ---------------------------------------------------------------------
\begin{frame}{}
\lstinputlisting{images/boxIsInt.js}
\end{frame}
% ------------------------------------------------------------------------------

\begin{frame}{Primitive Functions}
    \begin{itemize}
        \item Writing code using IIR not as painful as it sounds
        \item Using IIR does not take away JS capabilities!
        \begin{itemize}
            \item Still get dynamic typing, strings, closures
        \end{itemize}

        \item Don't need to annotate the type of every local variable

        \item Also facilitated by auto-generated code

        \item Auto-generated accessor methods for heap objects
        \begin{itemize}
            \item allo\_str(len), get\_str\_len(str), get\_str\_data(str, i)
        \end{itemize}

        \item Auto-generated C FFI wrappers
        \begin{itemize}
            \item puts('Hello World!'), malloc(size), free(ptr), exit(intval)
        \end{itemize}

    \end{itemize}
\end{frame}

\begin{frame}{}
\lstinputlisting[scale=0.8]{images/newObject.js}
\end{frame}

\begin{frame}{}
\lstinputlisting[scale=0.8]{images/boxToCString.js}
\end{frame}

% -- Slide ---------------------------------------------------------------------
\begin{frame}{Optimistic Optimizations}
    \begin{itemize}
        \item Traditional optimizations are conservative
        \begin{itemize}
            \item Can't prove it, can't do it
            \item Dynamic languages offer little static type information
            \item Dynamic constructs problematic for analysis
            \begin{itemize}
                \item eval, load
            \end{itemize}
            \item Often can't prove validity conservatively
        \end{itemize}

        \item Optimistic optimizations
        \begin{itemize}
            \item Valid now, assume valid until proven otherwise
            \item Most dynamic programs not that dynamic
            \item Many optimizations do apply
        \end{itemize}
    \end{itemize}
\end{frame}
% ------------------------------------------------------------------------------

% -- Slide ---------------------------------------------------------------------
\begin{frame}{Example: Optimization Issues}
    \lstinputlisting{images/sum.js}
    \begin{itemize}
        \item Don't know type of \code{list} and its elements
        \begin{itemize}
            \item Dynamic type checks needed
        \end{itemize}
        \item Name \code{f} is global, can be redefined
        \begin{itemize}
            \item Fetch from global object, is-function check needed
            \item Can't trivially perform inlining
            \item \code{f} could possibly change \code{list.length}
        \end{itemize}
        \item What if we add an eval?
    \end{itemize}
\end{frame}
% ------------------------------------------------------------------------------

% -- Slide ---------------------------------------------------------------------
\begin{frame}{Realistic Assumptions}
    \begin{itemize}
        \item As programmers, it's fairly obvious to us that:
        \begin{itemize}
            \item function \code{f} is extremely unlikely to be redefined
            \item list will likely always be array of integers
        \end{itemize}

        \item Not obvious to a compiler, but, in general:
        \begin{itemize}
            \item How often are global functions redefined?
            \item How many call sites are truly polymorphic?
            \item How many function arguments can have more than one type?
            \item How often do people use eval to change local variable types?
        \end{itemize}
    \end{itemize}
\end{frame}
% ------------------------------------------------------------------------------

% -- Slide ---------------------------------------------------------------------
\begin{frame}{What Would Tachyon Do (WWTD)?}
\begin{itemize}
    \item A VM can observe the types of global variables as a program is executing
    \begin{itemize}
        \item Can assume that these types will not change
        \begin{itemize}
            \item e.g.: assume that \code{f()} will not be redefined
        \end{itemize}
        \item Compile functions with these assumptions
    \end{itemize}

    \item A VM can observe what types input arguments to a function have
    \begin{itemize}
        \item Can specialize functions based on these
        \begin{itemize}
            \item e.g.: sum(list) is always called with arrays of integers
        \end{itemize}
    \end{itemize}

    \item Types inside of function bodies can be inferred from types of globals and arguments
    \begin{itemize}
        \item Type propagation, simple dataflow analysis
    \end{itemize}
\end{itemize}
\end{frame}
% ------------------------------------------------------------------------------

% -- Slide ---------------------------------------------------------------------
\begin{frame}{What Would Tachyon Do (WWTD)?}
\begin{center}
\includegraphics[width=3in]{images/transforms2}
\end{center}
\end{frame}
% ------------------------------------------------------------------------------

% -- Slide ---------------------------------------------------------------------
\begin{frame}{What Would Tachyon Do (WWTD)?}
\begin{center}
\includegraphics[height=2.8in]{images/execmodel}
\end{center}
\end{frame}
% ------------------------------------------------------------------------------

% -- Slide ---------------------------------------------------------------------
\begin{frame}{Key Ideas}
    \begin{itemize}
        \item Crucial to capture info about run time behavior
        \begin{itemize}
            \item Tracing JITs do this, but leave many run-time checks
        \end{itemize}

        \item Program needs to be correct at all times
        \begin{itemize}
            \item Don't need to run the same code at all times
            \item Multiple optimized versions correct at different times
        \end{itemize}

        \item Can make optimistic assumptions that may be invalidated
        \begin{itemize}
            \item So long as we can repair our mistakes in time
            \item Code with broken assumptions must never be executed
            \item Ideally, want invalidation to be unlikely
        \end{itemize}
    \end{itemize}
\end{frame}
% ------------------------------------------------------------------------------

% -- Slide ---------------------------------------------------------------------
\begin{frame}{Type Profiling}
    \begin{itemize}
        \item Type profiling can observe:
        \begin{itemize}
            \item Frequency of calls
            \item Types of arguments to calls
            \item Types of values stored into globals
            \item Types of values stored in object fields
        \end{itemize}

        \item Goal: build fairly accurate profile of program behavior w.r.t. types
    \end{itemize}
\end{frame}
% ------------------------------------------------------------------------------

% -- Slide ---------------------------------------------------------------------
\begin{frame}{Type Propagation}
    \begin{itemize}
        \item Form of type inference
        \item Dataflow analysis
        \item Local or whole program
        \item Rules depend on language semantics, e.g.:
        \begin{itemize}
            \item add int, int $\rightarrow$ int
            \item add float, float $\rightarrow$ float
            \item mul m4x2, m2x1 $\rightarrow$ m4x1
            \item getprop o, “a” $\rightarrow$ prop\_type(o, “a”)
        \end{itemize}

        \item In the local case, inputs are function argument types, globals types, closure variable types
        \item Output: local variable types, return type
    \end{itemize}
\end{frame}
% ------------------------------------------------------------------------------

% -- Slide ---------------------------------------------------------------------
\begin{frame}{Potential Difficulties}
    \begin{itemize}
        \item Cost of profiling
        \begin{itemize}
            \item Need accurate information
        \end{itemize}
        \item Cost of recompilation
        \begin{itemize}
            \item Usage of external threads
        \end{itemize}
        \item Frequency of recompilation
        \begin{itemize}
            \item Progressive pessimization
        \end{itemize}
        \item Inherent complexity
        \begin{itemize}
            \item Find more students!
        \end{itemize}
    \end{itemize}
\end{frame}
% ------------------------------------------------------------------------------

% -- Slide ---------------------------------------------------------------------
\begin{frame}{Related Work: Type Analysis}
    \begin{itemize}
        \item M Chevalier-Boisvert, L Hendren, C Verbrugge. \textit{Optimizing
        MATLAB through just-in-time specialization}. CC 2010.
        \item F Logozzo, H Venter. \textit{RATA: Rapid Atomic Type Analysis by
        Abstract Interpretation–Application to JavaScript Optimization}. CC
        2010.
        \item S Jensen, A M\o{}ller et al. \textit{Type analysis for JavaScript}. SAS 2009.
        \item And much more\ldots
    \end{itemize}
\end{frame}
% ------------------------------------------------------------------------------

% -- Slide ---------------------------------------------------------------------
\begin{frame}{Related work: Deoptimization}
    \begin{itemize}
        \item I Pechtchanski, V Sarkar. \textit{Dynamic optimistic
            interprocedural analysis: a framework and an application}. OOPSLA 2001.
        \begin{itemize}
            \item Systematic optimistic interprocedural type analysis to optimize polymorphic call sites
        \end{itemize}
        \item Speculative inlining
        \begin{itemize}
            \item In Java, dynamic class loading can invalidate inlining decisions
            \item Implemented in Java HotSpot VM
        \end{itemize}
        \item Polymorphic inline cache
    \end{itemize}
\end{frame}
% ------------------------------------------------------------------------------

% -- Slide ---------------------------------------------------------------------
\begin{frame}{Related Work: Tracing JITs}
    \begin{itemize}
        \item HotpathVM, TraceMonkey, LuaJIT, etc.
        \item Tracing JITs are another dynamic compilation model

        \item Same basic underlying principle
        \begin{itemize}
            \item Observe program as it runs, gather data about behavior
            \item Assume current behavior will likely persist, use data to specialize program, minimize dynamic checks
        \end{itemize}

        \item Main limitations
        \begin{itemize}
            \item Local approach, detects \& examines loops
            \item Knows little about what goes on outside loops
            \item No real way of dealing with global data, optimizing object layout, etc.
        \end{itemize}
    \end{itemize}
\end{frame}
% ------------------------------------------------------------------------------

